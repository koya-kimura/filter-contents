{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\takum\\\\Documents\\\\GitHub\\\\filter-contents\\\\src\\\\CaptureContainer\\\\CameraCapture\\\\CameraCapture.js\";\nimport React, { Component } from \"react\";\nimport p5 from 'p5';\n\n// GLSLソースファイルのパスリスト\nimport { fileList } from \"./fileList\";\n\n// 利用するシェーダのインデックス\nimport { shaderIndex } from \"../../../src/App\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet P;\n//let w, h;\n\nexport default class CameraCapture extends Component {\n  constructor(props) {\n    super(props);\n    this.sketchHandler = p => {\n      let filterShaders = []; // シェーダオブジェクト\n      let capture; // カメラのキャプチャ\n      // const scl = 0.8;\n      // const scl = 0.75;\n      const scl = 0.5;\n      let scale;\n      let offsetX, offsetY;\n      p.preload = () => {\n        fileList.forEach(fp => {\n          filterShaders.push(p.loadShader(fp.vert, fp.frag));\n        });\n      };\n      p.setup = () => {\n        // saveImage()関数を使うためにpをグローバルへ引き上げる（かなりの荒業）\n        P = p;\n\n        // メインキャンバスの作成\n        p.createCanvas(p.windowWidth * scl, p.windowHeight * scl, p.WEBGL);\n        // p.createCanvas(p.windowWidth * scl, p.windowHeight * scl);\n        // p.createCanvas(p.windowWidth * scale, p.windowHeight * scale, p.WEBGL);\n\n        // 仮想キャンバスの作成\n        // pg = p5.createGraphics(p5.width, p5.height);\n\n        // Webカメラのキャプチャ開始\n        capture = p.createCapture(p.VIDEO);\n        // capture = p.createCapture(p.VIDEO, { flipped: true });\n        // console.log(p.createCapture);\n        // capture = p.createCapture(p.VIDEO, true);\n\n        // カメラの解像度\n        capture.size(640, 480);\n        capture.hide();\n\n        // キャンバスサイズを考慮したカメラの比率計算\n        calculateLayout();\n      };\n      p.draw = () => {\n        p.shader(filterShaders[shaderIndex]);\n        filterShaders[shaderIndex].setUniform(\"u_time\", p.frameCount / 100);\n        // filterShaders[shaderIndex].setUniform(\"u_Resolution\", [p.width, p.height]);\n        filterShaders[shaderIndex].setUniform(\"u_Resolution\", [capture.width * scale, capture.height * scale]);\n        filterShaders[shaderIndex].setUniform(\"u_tex\", capture);\n\n        // filterShaders.setUniform('u_color0', normalizeColors[0]);\n        // filterShaders.setUniform('u_color1', normalizeColors[1]);\n        // filterShaders.setUniform('u_color2', normalizeColors[2]);\n        // filterShaders.setUniform('u_color3', normalizeColors[3]);\n        // filterShaders.setUniform('u_color4', normalizeColors[4]);\n\n        // p.rect(0, 0, p.width, p.height);\n        p.rect(0, 0, 1, 1);\n        // p.rect(0, 0, capture.width * scale, capture.height * scale);\n\n        // console.log(scale);\n\n        // w = p.windowWidth * scl / p.windowWidth * 100;\n        // h = p.windowHeight * scl;\n        // console.log(w + \", \" + P.width)\n      };\n      p.windowResized = () => {\n        p.resizeCanvas(p.windowWidth * scl, p.windowHeight * scl, p.WEBGL);\n        // p.resizeCanvas(p.windowWidth * scale, p.windowHeight * scale, p.WEBGL);\n\n        // キャンバスサイズを考慮したカメラの比率計算\n        calculateLayout();\n      };\n\n      // キャンバスサイズを考慮したカメラの比率計算\n      function calculateLayout() {\n        // function calculateLayout = () => {\n        // キャンバスとカメラ映像のアスペクト比に基づくスケーリング比を計算\n        scale = p.min(p.width / capture.width, p.height / capture.height);\n\n        // スケーリングされた映像のサイズを計算\n        let scaledWidth = capture.width * scale;\n        let scaledHeight = capture.height * scale;\n        console.log(p.width);\n\n        // スケーリングされた映像を中央に配置するためのオフセットを計算\n        offsetX = (p.width - scaledWidth) / 2;\n        offsetY = (p.height - scaledHeight) / 2;\n      }\n    };\n    this.sketchRef = /*#__PURE__*/React.createRef();\n  }\n  componentDidMount() {\n    this.sketch = new p5(this.sketchHandler, this.sketchRef.current);\n  }\n  componentWillUnmount() {\n    this.sketch.remove();\n  }\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"CameraCapture\",\n      ref: this.sketchRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 7\n    }, this);\n  }\n}\n\n// 画像の保存\nexport function saveImage() {\n  P.saveCanvas();\n}","map":{"version":3,"names":["React","Component","p5","fileList","shaderIndex","jsxDEV","_jsxDEV","P","CameraCapture","constructor","props","sketchHandler","p","filterShaders","capture","scl","scale","offsetX","offsetY","preload","forEach","fp","push","loadShader","vert","frag","setup","createCanvas","windowWidth","windowHeight","WEBGL","createCapture","VIDEO","size","hide","calculateLayout","draw","shader","setUniform","frameCount","width","height","rect","windowResized","resizeCanvas","min","scaledWidth","scaledHeight","console","log","sketchRef","createRef","componentDidMount","sketch","current","componentWillUnmount","remove","render","className","ref","fileName","_jsxFileName","lineNumber","columnNumber","saveImage","saveCanvas"],"sources":["C:/Users/takum/Documents/GitHub/filter-contents/src/CaptureContainer/CameraCapture/CameraCapture.js"],"sourcesContent":["import React, { Component } from \"react\";\r\nimport p5 from 'p5';\r\n\r\n// GLSLソースファイルのパスリスト\r\nimport { fileList } from \"./fileList\";\r\n\r\n// 利用するシェーダのインデックス\r\nimport { shaderIndex } from \"../../../src/App\"\r\n\r\nlet P;\r\n//let w, h;\r\n\r\nexport default class CameraCapture extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.sketchRef = React.createRef();\r\n  }\r\n\r\n\r\n  componentDidMount() {\r\n    this.sketch = new p5(this.sketchHandler, this.sketchRef.current);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.sketch.remove();\r\n  }\r\n\r\n  sketchHandler = p => {\r\n    let filterShaders = []; // シェーダオブジェクト\r\n    let capture;        // カメラのキャプチャ\r\n    // const scl = 0.8;\r\n    // const scl = 0.75;\r\n    const scl = 0.5;\r\n\r\n    let scale;\r\n    let offsetX, offsetY;\r\n\r\n    p.preload = () => {\r\n      fileList.forEach(fp => {\r\n        filterShaders.push(p.loadShader(fp.vert, fp.frag));\r\n      });\r\n    };\r\n\r\n    p.setup = () => {\r\n      // saveImage()関数を使うためにpをグローバルへ引き上げる（かなりの荒業）\r\n      P = p;\r\n\r\n      // メインキャンバスの作成\r\n      p.createCanvas(p.windowWidth * scl, p.windowHeight * scl, p.WEBGL);\r\n      // p.createCanvas(p.windowWidth * scl, p.windowHeight * scl);\r\n      // p.createCanvas(p.windowWidth * scale, p.windowHeight * scale, p.WEBGL);\r\n\r\n      // 仮想キャンバスの作成\r\n      // pg = p5.createGraphics(p5.width, p5.height);\r\n\r\n      // Webカメラのキャプチャ開始\r\n      capture = p.createCapture(p.VIDEO);\r\n      // capture = p.createCapture(p.VIDEO, { flipped: true });\r\n      // console.log(p.createCapture);\r\n      // capture = p.createCapture(p.VIDEO, true);\r\n\r\n      // カメラの解像度\r\n      capture.size(640, 480);\r\n      capture.hide();\r\n\r\n      // キャンバスサイズを考慮したカメラの比率計算\r\n      calculateLayout();\r\n    };\r\n\r\n    p.draw = () => {\r\n      p.shader(filterShaders[shaderIndex]);\r\n\r\n      filterShaders[shaderIndex].setUniform(\"u_time\", p.frameCount / 100);\r\n      // filterShaders[shaderIndex].setUniform(\"u_Resolution\", [p.width, p.height]);\r\n      filterShaders[shaderIndex].setUniform(\"u_Resolution\", [capture.width * scale, capture.height * scale]);\r\n\r\n      filterShaders[shaderIndex].setUniform(\"u_tex\", capture);\r\n\r\n      // filterShaders.setUniform('u_color0', normalizeColors[0]);\r\n      // filterShaders.setUniform('u_color1', normalizeColors[1]);\r\n      // filterShaders.setUniform('u_color2', normalizeColors[2]);\r\n      // filterShaders.setUniform('u_color3', normalizeColors[3]);\r\n      // filterShaders.setUniform('u_color4', normalizeColors[4]);\r\n\r\n      // p.rect(0, 0, p.width, p.height);\r\n      p.rect(0, 0, 1, 1);\r\n      // p.rect(0, 0, capture.width * scale, capture.height * scale);\r\n\r\n      // console.log(scale);\r\n\r\n      // w = p.windowWidth * scl / p.windowWidth * 100;\r\n      // h = p.windowHeight * scl;\r\n      // console.log(w + \", \" + P.width)\r\n    };\r\n\r\n    p.windowResized = () => {\r\n      p.resizeCanvas(p.windowWidth * scl, p.windowHeight * scl, p.WEBGL);\r\n      // p.resizeCanvas(p.windowWidth * scale, p.windowHeight * scale, p.WEBGL);\r\n\r\n      // キャンバスサイズを考慮したカメラの比率計算\r\n      calculateLayout();\r\n    }\r\n\r\n    // キャンバスサイズを考慮したカメラの比率計算\r\n    function calculateLayout() {\r\n      // function calculateLayout = () => {\r\n      // キャンバスとカメラ映像のアスペクト比に基づくスケーリング比を計算\r\n      scale = p.min(p.width / capture.width, p.height / capture.height);\r\n\r\n      // スケーリングされた映像のサイズを計算\r\n      let scaledWidth = capture.width * scale;\r\n      let scaledHeight = capture.height * scale;\r\n      console.log(p.width);\r\n\r\n\r\n      // スケーリングされた映像を中央に配置するためのオフセットを計算\r\n      offsetX = (p.width - scaledWidth) / 2;\r\n      offsetY = (p.height - scaledHeight) / 2;\r\n\r\n    }\r\n  };\r\n\r\n\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"CameraCapture\" ref={this.sketchRef}></div>\r\n    );\r\n  }\r\n}\r\n\r\n\r\n\r\n// 画像の保存\r\nexport function saveImage() {\r\n  P.saveCanvas();\r\n}\r\n"],"mappings":";AAAA,OAAOA,KAAK,IAAIC,SAAS,QAAQ,OAAO;AACxC,OAAOC,EAAE,MAAM,IAAI;;AAEnB;AACA,SAASC,QAAQ,QAAQ,YAAY;;AAErC;AACA,SAASC,WAAW,QAAQ,kBAAkB;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAE9C,IAAIC,CAAC;AACL;;AAEA,eAAe,MAAMC,aAAa,SAASP,SAAS,CAAC;EACnDQ,WAAWA,CAACC,KAAK,EAAE;IACjB,KAAK,CAACA,KAAK,CAAC;IAAC,KAafC,aAAa,GAAGC,CAAC,IAAI;MACnB,IAAIC,aAAa,GAAG,EAAE,CAAC,CAAC;MACxB,IAAIC,OAAO,CAAC,CAAQ;MACpB;MACA;MACA,MAAMC,GAAG,GAAG,GAAG;MAEf,IAAIC,KAAK;MACT,IAAIC,OAAO,EAAEC,OAAO;MAEpBN,CAAC,CAACO,OAAO,GAAG,MAAM;QAChBhB,QAAQ,CAACiB,OAAO,CAACC,EAAE,IAAI;UACrBR,aAAa,CAACS,IAAI,CAACV,CAAC,CAACW,UAAU,CAACF,EAAE,CAACG,IAAI,EAAEH,EAAE,CAACI,IAAI,CAAC,CAAC;QACpD,CAAC,CAAC;MACJ,CAAC;MAEDb,CAAC,CAACc,KAAK,GAAG,MAAM;QACd;QACAnB,CAAC,GAAGK,CAAC;;QAEL;QACAA,CAAC,CAACe,YAAY,CAACf,CAAC,CAACgB,WAAW,GAAGb,GAAG,EAAEH,CAAC,CAACiB,YAAY,GAAGd,GAAG,EAAEH,CAAC,CAACkB,KAAK,CAAC;QAClE;QACA;;QAEA;QACA;;QAEA;QACAhB,OAAO,GAAGF,CAAC,CAACmB,aAAa,CAACnB,CAAC,CAACoB,KAAK,CAAC;QAClC;QACA;QACA;;QAEA;QACAlB,OAAO,CAACmB,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC;QACtBnB,OAAO,CAACoB,IAAI,CAAC,CAAC;;QAEd;QACAC,eAAe,CAAC,CAAC;MACnB,CAAC;MAEDvB,CAAC,CAACwB,IAAI,GAAG,MAAM;QACbxB,CAAC,CAACyB,MAAM,CAACxB,aAAa,CAACT,WAAW,CAAC,CAAC;QAEpCS,aAAa,CAACT,WAAW,CAAC,CAACkC,UAAU,CAAC,QAAQ,EAAE1B,CAAC,CAAC2B,UAAU,GAAG,GAAG,CAAC;QACnE;QACA1B,aAAa,CAACT,WAAW,CAAC,CAACkC,UAAU,CAAC,cAAc,EAAE,CAACxB,OAAO,CAAC0B,KAAK,GAAGxB,KAAK,EAAEF,OAAO,CAAC2B,MAAM,GAAGzB,KAAK,CAAC,CAAC;QAEtGH,aAAa,CAACT,WAAW,CAAC,CAACkC,UAAU,CAAC,OAAO,EAAExB,OAAO,CAAC;;QAEvD;QACA;QACA;QACA;QACA;;QAEA;QACAF,CAAC,CAAC8B,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAClB;;QAEA;;QAEA;QACA;QACA;MACF,CAAC;MAED9B,CAAC,CAAC+B,aAAa,GAAG,MAAM;QACtB/B,CAAC,CAACgC,YAAY,CAAChC,CAAC,CAACgB,WAAW,GAAGb,GAAG,EAAEH,CAAC,CAACiB,YAAY,GAAGd,GAAG,EAAEH,CAAC,CAACkB,KAAK,CAAC;QAClE;;QAEA;QACAK,eAAe,CAAC,CAAC;MACnB,CAAC;;MAED;MACA,SAASA,eAAeA,CAAA,EAAG;QACzB;QACA;QACAnB,KAAK,GAAGJ,CAAC,CAACiC,GAAG,CAACjC,CAAC,CAAC4B,KAAK,GAAG1B,OAAO,CAAC0B,KAAK,EAAE5B,CAAC,CAAC6B,MAAM,GAAG3B,OAAO,CAAC2B,MAAM,CAAC;;QAEjE;QACA,IAAIK,WAAW,GAAGhC,OAAO,CAAC0B,KAAK,GAAGxB,KAAK;QACvC,IAAI+B,YAAY,GAAGjC,OAAO,CAAC2B,MAAM,GAAGzB,KAAK;QACzCgC,OAAO,CAACC,GAAG,CAACrC,CAAC,CAAC4B,KAAK,CAAC;;QAGpB;QACAvB,OAAO,GAAG,CAACL,CAAC,CAAC4B,KAAK,GAAGM,WAAW,IAAI,CAAC;QACrC5B,OAAO,GAAG,CAACN,CAAC,CAAC6B,MAAM,GAAGM,YAAY,IAAI,CAAC;MAEzC;IACF,CAAC;IAzGC,IAAI,CAACG,SAAS,gBAAGlD,KAAK,CAACmD,SAAS,CAAC,CAAC;EACpC;EAGAC,iBAAiBA,CAAA,EAAG;IAClB,IAAI,CAACC,MAAM,GAAG,IAAInD,EAAE,CAAC,IAAI,CAACS,aAAa,EAAE,IAAI,CAACuC,SAAS,CAACI,OAAO,CAAC;EAClE;EAEAC,oBAAoBA,CAAA,EAAG;IACrB,IAAI,CAACF,MAAM,CAACG,MAAM,CAAC,CAAC;EACtB;EAmGAC,MAAMA,CAAA,EAAG;IACP,oBACEnD,OAAA;MAAKoD,SAAS,EAAC,eAAe;MAACC,GAAG,EAAE,IAAI,CAACT;IAAU;MAAAU,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAM,CAAC;EAE9D;AACF;;AAIA;AACA,OAAO,SAASC,SAASA,CAAA,EAAG;EAC1BzD,CAAC,CAAC0D,UAAU,CAAC,CAAC;AAChB"},"metadata":{},"sourceType":"module","externalDependencies":[]}